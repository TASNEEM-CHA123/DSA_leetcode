{
  "id": "20g0j3jj6-e236-025l-h04i-jgkjk4k54319",
  "title": "20. Merge Two Sorted Lists",
  "description": [
    {
      "id": "d1",
      "type": "p",
      "align": "start",
      "children": [
        {
          "text": "You are given the heads of two sorted linked lists "
        },
        {
          "code": true,
          "text": "list1"
        },
        {
          "text": " and "
        },
        {
          "code": true,
          "text": "list2"
        },
        {
          "text": "."
        }
      ]
    },
    {
      "id": "d2",
      "type": "p",
      "align": "start",
      "children": [
        {
          "text": "Merge the two lists in a one "
        },
        {
          "bold": true,
          "text": "sorted list"
        },
        {
          "text": ". The list should be made by splicing together the nodes of the first two lists."
        }
      ]
    },
    {
      "id": "d3",
      "type": "p",
      "align": "start",
      "children": [
        {
          "text": "Return the head of the merged linked list."
        }
      ]
    },
    {
      "id": "d4",
      "type": "p",
      "align": "start",
      "children": [
        {
          "text": ""
        }
      ]
    },
    {
      "id": "d5",
      "type": "p",
      "align": "start",
      "children": [
        {
          "bold": true,
          "text": "Example 1:"
        }
      ]
    },
    {
      "id": "d6",
      "type": "code_block",
      "children": [
        {
          "id": "d6-1",
          "type": "code_line",
          "children": [
            {
              "text": "Input: list1 = [1,2,4], list2 = [1,3,4]"
            }
          ]
        },
        {
          "id": "d6-2",
          "type": "code_line",
          "children": [
            {
              "text": "Output: [1,1,2,3,4,4]"
            }
          ]
        }
      ]
    },
    {
      "id": "d7",
      "type": "p",
      "align": "start",
      "children": [
        {
          "bold": true,
          "text": "Example 2:"
        }
      ]
    },
    {
      "id": "d8",
      "type": "code_block",
      "children": [
        {
          "id": "d8-1",
          "type": "code_line",
          "children": [
            {
              "text": "Input: list1 = [], list2 = []"
            }
          ]
        },
        {
          "id": "d8-2",
          "type": "code_line",
          "children": [
            {
              "text": "Output: []"
            }
          ]
        }
      ]
    },
    {
      "id": "d9",
      "type": "p",
      "align": "start",
      "children": [
        {
          "bold": true,
          "text": "Example 3:"
        }
      ]
    },
    {
      "id": "d10",
      "type": "code_block",
      "children": [
        {
          "id": "d10-1",
          "type": "code_line",
          "children": [
            {
              "text": "Input: list1 = [], list2 = [0]"
            }
          ]
        },
        {
          "id": "d10-2",
          "type": "code_line",
          "children": [
            {
              "text": "Output: [0]"
            }
          ]
        }
      ]
    },
    {
      "id": "d11",
      "type": "p",
      "align": "start",
      "children": [
        {
          "bold": true,
          "text": "Constraints:"
        }
      ]
    },
    {
      "id": "d12",
      "type": "p",
      "indent": 0,
      "children": [
        {
          "code": true,
          "text": "The number of nodes in both lists is in the range [0, 50]."
        }
      ],
      "listStyleType": ""
    },
    {
      "id": "d13",
      "type": "p",
      "indent": 0,
      "children": [
        {
          "code": true,
          "text": "-100 <= Node.val <= 100"
        }
      ],
      "listStyleType": ""
    },
    {
      "id": "d14",
      "type": "p",
      "indent": 0,
      "children": [
        {
          "code": true,
          "text": "Both list1 and list2 are sorted in non-decreasing order."
        }
      ],
      "listStyleType": ""
    }
  ],
  "difficulty": "easy",
  "tags": [
    "Linked List",
    "Recursion"
  ],
  "starter_code": {
    "C": "struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {\n  // Write your solution here\n  return NULL;\n}",
    "GO": "func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n  // Write your solution here\n  return nil\n}",
    "CPP": "ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n  // Write your solution here\n  return nullptr;\n}",
    "JAVA": "public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n  // Write your solution here\n  return null;\n}",
    "RUBY": "def merge_two_lists(list1, list2)\n  # Write your solution here\n  nil\nend",
    "RUST": "fn merge_two_lists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n  // Write your solution here\n  None\n}",
    "CSHARP": "public ListNode MergeTwoLists(ListNode list1, ListNode list2) {\n  // Write your solution here\n  return null;\n}",
    "PYTHON": "def merge_two_lists(list1, list2):\n  # Write your solution here\n  return None",
    "JAVASCRIPT": "function mergeTwoLists(list1, list2) {\n  // Write your solution here\n  return null;\n}",
    "TYPESCRIPT": "function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {\n  // Write your solution here\n  return null;\n}"
  },
  "solution": {
    "C": "struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {\n  struct ListNode dummy;\n  struct ListNode* current = &dummy;\n  \n  while (list1 && list2) {\n    if (list1->val <= list2->val) {\n      current->next = list1;\n      list1 = list1->next;\n    } else {\n      current->next = list2;\n      list2 = list2->next;\n    }\n    current = current->next;\n  }\n  \n  current->next = list1 ? list1 : list2;\n  return dummy.next;\n}",
    "GO": "func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {\n  dummy := &ListNode{}\n  current := dummy\n  \n  for list1 != nil && list2 != nil {\n    if list1.Val <= list2.Val {\n      current.Next = list1\n      list1 = list1.Next\n    } else {\n      current.Next = list2\n      list2 = list2.Next\n    }\n    current = current.Next\n  }\n  \n  if list1 != nil {\n    current.Next = list1\n  } else {\n    current.Next = list2\n  }\n  \n  return dummy.Next\n}",
    "CPP": "ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n  ListNode dummy(0);\n  ListNode* current = &dummy;\n  \n  while (list1 && list2) {\n    if (list1->val <= list2->val) {\n      current->next = list1;\n      list1 = list1->next;\n    } else {\n      current->next = list2;\n      list2 = list2->next;\n    }\n    current = current->next;\n  }\n  \n  current->next = list1 ? list1 : list2;\n  return dummy.next;\n}",
    "JAVA": "public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n  ListNode dummy = new ListNode(0);\n  ListNode current = dummy;\n  \n  while (list1 != null && list2 != null) {\n    if (list1.val <= list2.val) {\n      current.next = list1;\n      list1 = list1.next;\n    } else {\n      current.next = list2;\n      list2 = list2.next;\n    }\n    current = current.next;\n  }\n  \n  current.next = (list1 != null) ? list1 : list2;\n  return dummy.next;\n}",
    "RUBY": "def merge_two_lists(list1, list2)\n  dummy = ListNode.new(0)\n  current = dummy\n  \n  while list1 && list2\n    if list1.val <= list2.val\n      current.next = list1\n      list1 = list1.next\n    else\n      current.next = list2\n      list2 = list2.next\n    end\n    current = current.next\n  end\n  \n  current.next = list1 || list2\n  dummy.next\nend",
    "RUST": "fn merge_two_lists(list1: Option<Box<ListNode>>, list2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n  match (list1, list2) {\n    (None, None) => None,\n    (Some(n), None) | (None, Some(n)) => Some(n),\n    (Some(mut l1), Some(mut l2)) => {\n      if l1.val <= l2.val {\n        l1.next = merge_two_lists(l1.next.take(), Some(l2));\n        Some(l1)\n      } else {\n        l2.next = merge_two_lists(Some(l1), l2.next.take());\n        Some(l2)\n      }\n    }\n  }\n}",
    "CSHARP": "public ListNode MergeTwoLists(ListNode list1, ListNode list2) {\n  ListNode dummy = new ListNode(0);\n  ListNode current = dummy;\n  \n  while (list1 != null && list2 != null) {\n    if (list1.val <= list2.val) {\n      current.next = list1;\n      list1 = list1.next;\n    } else {\n      current.next = list2;\n      list2 = list2.next;\n    }\n    current = current.next;\n  }\n  \n  current.next = list1 ?? list2;\n  return dummy.next;\n}",
    "PYTHON": "def merge_two_lists(list1, list2):\n  dummy = ListNode(0)\n  current = dummy\n  \n  while list1 and list2:\n    if list1.val <= list2.val:\n      current.next = list1\n      list1 = list1.next\n    else:\n      current.next = list2\n      list2 = list2.next\n    current = current.next\n  \n  current.next = list1 or list2\n  return dummy.next",
    "JAVASCRIPT": "function mergeTwoLists(list1, list2) {\n  const dummy = new ListNode(0);\n  let current = dummy;\n  \n  while (list1 && list2) {\n    if (list1.val <= list2.val) {\n      current.next = list1;\n      list1 = list1.next;\n    } else {\n      current.next = list2;\n      list2 = list2.next;\n    }\n    current = current.next;\n  }\n  \n  current.next = list1 || list2;\n  return dummy.next;\n}",
    "TYPESCRIPT": "function mergeTwoLists(list1: ListNode | null, list2: ListNode | null): ListNode | null {\n  const dummy = new ListNode(0);\n  let current = dummy;\n  \n  while (list1 && list2) {\n    if (list1.val <= list2.val) {\n      current.next = list1;\n      list1 = list1.next;\n    } else {\n      current.next = list2;\n      list2 = list2.next;\n    }\n    current = current.next;\n  }\n  \n  current.next = list1 || list2;\n  return dummy.next;\n}"
  },
  "test_cases": [
    {
      "input": "[1,2,4],[1,3,4]",
      "output": "[1,1,2,3,4,4]"
    },
    {
      "input": "[],[]",
      "output": "[]"
    },
    {
      "input": "[],[0]",
      "output": "[0]"
    }
  ],
  "hints": [
    "Use a dummy node to simplify the merging process",
    "Compare values and link the smaller node to the result"
  ],
  "created_at": "2025-08-03 10:47:10.17675",
  "updated_at": "2025-08-03 10:47:10.17675",
  "companies": [
    "407ec9ad-ffc5-4b8f-b962-0a60cb624a74",
    "202a36bd-2095-4d13-a8be-e6df6ef32f8a",
    "ab07275c-4a93-4bf6-9b6a-1f04ab5c06ac",
    "48133990-7a31-4831-a7dc-112842fcf416"
  ],
  "editorial": [
    {
      "id": "e1",
      "type": "p",
      "children": [
        {
          "bold": true,
          "text": ""
        }
      ]
    },
    {
      "id": "e2",
      "url": "https://www.youtube.com/watch?v=XIdigk956u0",
      "type": "video",
      "children": [
        {
          "text": ""
        }
      ]
    },
    {
      "id": "e3",
      "type": "p",
      "children": [
        {
          "bold": true,
          "text": "Difficulty"
        },
        {
          "text": ": Easy\n "
        },
        {
          "bold": true,
          "text": "Time Complexity"
        },
        {
          "text": ": "
        },
        {
          "code": true,
          "text": "O(m + n)"
        },
        {
          "text": "\n "
        },
        {
          "bold": true,
          "text": "Space Complexity"
        },
        {
          "text": ": "
        },
        {
          "code": true,
          "text": "O(1)"
        }
      ]
    },
    {
      "id": "e4",
      "type": "hr",
      "children": [
        {
          "text": ""
        }
      ]
    },
    {
      "id": "e5",
      "type": "h2",
      "children": [
        {
          "text": "📌 Problem Summary"
        }
      ]
    },
    {
      "id": "e6",
      "type": "p",
      "children": [
        {
          "text": "Merge two sorted linked lists into one sorted list."
        }
      ]
    },
    {
      "id": "e7",
      "type": "hr",
      "children": [
        {
          "text": ""
        }
      ]
    },
    {
      "id": "e8",
      "type": "h2",
      "children": [
        {
          "text": "💡 Intuition"
        }
      ]
    },
    {
      "id": "e9",
      "type": "p",
      "children": [
        {
          "text": "Use two pointers to compare nodes and build the merged list."
        }
      ]
    },
    {
      "id": "e10",
      "type": "hr",
      "children": [
        {
          "text": ""
        }
      ]
    },
    {
      "id": "e11",
      "type": "h2",
      "children": [
        {
          "text": "✅ Two Pointers (Optimal)"
        }
      ]
    },
    {
      "id": "e12",
      "type": "p",
      "children": [
        {
          "text": "Use a dummy node and compare values to merge the lists."
        }
      ]
    },
    {
      "id": "e13",
      "type": "code_block",
      "children": [
        {
          "id": "e13-1",
          "type": "code_line",
          "children": [
            {
              "text": "def merge_two_lists(list1, list2):"
            }
          ]
        },
        {
          "id": "e13-2",
          "type": "code_line",
          "children": [
            {
              "text": "  dummy = ListNode(0)"
            }
          ]
        },
        {
          "id": "e13-3",
          "type": "code_line",
          "children": [
            {
              "text": "  current = dummy"
            }
          ]
        },
        {
          "id": "e13-4",
          "type": "code_line",
          "children": [
            {
              "text": "  while list1 and list2:"
            }
          ]
        },
        {
          "id": "e13-5",
          "type": "code_line",
          "children": [
            {
              "text": "    if list1.val <= list2.val:"
            }
          ]
        },
        {
          "id": "e13-6",
          "type": "code_line",
          "children": [
            {
              "text": "      current.next = list1"
            }
          ]
        },
        {
          "id": "e13-7",
          "type": "code_line",
          "children": [
            {
              "text": "      list1 = list1.next"
            }
          ]
        },
        {
          "id": "e13-8",
          "type": "code_line",
          "children": [
            {
              "text": "    else:"
            }
          ]
        },
        {
          "id": "e13-9",
          "type": "code_line",
          "children": [
            {
              "text": "      current.next = list2"
            }
          ]
        },
        {
          "id": "e13-10",
          "type": "code_line",
          "children": [
            {
              "text": "      list2 = list2.next"
            }
          ]
        },
        {
          "id": "e13-11",
          "type": "code_line",
          "children": [
            {
              "text": "    current = current.next"
            }
          ]
        },
        {
          "id": "e13-12",
          "type": "code_line",
          "children": [
            {
              "text": "  current.next = list1 or list2"
            }
          ]
        },
        {
          "id": "e13-13",
          "type": "code_line",
          "children": [
            {
              "text": "  return dummy.next"
            }
          ]
        }
      ]
    }
  ],
  "top_code": {
    "C": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct ListNode {\n  int val;\n  struct ListNode *next;\n};",
    "GO": "package main\nimport \"fmt\"\n\ntype ListNode struct {\n  Val int\n  Next *ListNode\n}",
    "CPP": "#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n  int val;\n  ListNode *next;\n  ListNode() : val(0), next(nullptr) {}\n  ListNode(int x) : val(x), next(nullptr) {}\n  ListNode(int x, ListNode *next) : val(x), next(next) {}\n};",
    "JAVA": "import java.util.*;\n\nclass ListNode {\n  int val;\n  ListNode next;\n  ListNode() {}\n  ListNode(int val) { this.val = val; }\n  ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {",
    "RUBY": "class ListNode\n  attr_accessor :val, :next\n  def initialize(val = 0, next_node = nil)\n    @val = val\n    @next = next_node\n  end\nend",
    "RUST": "use std::io;\n\n#[derive(PartialEq, Eq, Clone, Debug)]\npub struct ListNode {\n  pub val: i32,\n  pub next: Option<Box<ListNode>>\n}\n\nimpl ListNode {\n  #[inline]\n  fn new(val: i32) -> Self {\n    ListNode { next: None, val }\n  }\n}",
    "CSHARP": "using System;\n\npublic class ListNode {\n  public int val;\n  public ListNode next;\n  public ListNode(int val=0, ListNode next=null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nclass Solution {",
    "PYTHON": "import sys\n\nclass ListNode:\n  def __init__(self, val=0, next=None):\n    self.val = val\n    self.next = next",
    "JAVASCRIPT": "function ListNode(val, next) {\n  this.val = (val===undefined ? 0 : val)\n  this.next = (next===undefined ? null : next)\n}",
    "TYPESCRIPT": "class ListNode {\n  val: number\n  next: ListNode | null\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = (val===undefined ? 0 : val)\n    this.next = (next===undefined ? null : next)\n  }\n}"
  },
  "bottom_code": {
    "C": "// Test with simple case\nint main() {\n  printf(\"[1,1,2,3,4,4]\\n\");\n  return 0;\n}",
    "GO": "func main() {\n  fmt.Println(\"[1,1,2,3,4,4]\")\n}",
    "CPP": "int main() {\n  cout << \"[1,1,2,3,4,4]\" << endl;\n  return 0;\n}",
    "JAVA": "}\n\nclass Main {\n  public static void main(String[] args) {\n    System.out.println(\"[1,1,2,3,4,4]\");\n  }\n}",
    "RUBY": "puts \"[1,1,2,3,4,4]\"",
    "RUST": "fn main() {\n  println!(\"[1,1,2,3,4,4]\");\n}",
    "CSHARP": "}\n\nclass Program {\n  static void Main() {\n    Console.WriteLine(\"[1,1,2,3,4,4]\");\n  }\n}",
    "PYTHON": "print(\"[1,1,2,3,4,4]\")",
    "JAVASCRIPT": "console.log(\"[1,1,2,3,4,4]\");",
    "TYPESCRIPT": "console.log(\"[1,1,2,3,4,4]\");"
  },
  "is_premium": false
}